import processing.core.*; 
import processing.data.*; 
import processing.event.*; 
import processing.opengl.*; 

import java.lang.Math; 
import java.util.Arrays; 

import java.util.HashMap; 
import java.util.ArrayList; 
import java.io.File; 
import java.io.BufferedReader; 
import java.io.PrintWriter; 
import java.io.InputStream; 
import java.io.OutputStream; 
import java.io.IOException; 

public class Grid extends PApplet {




//// Variables
// Mode variables
boolean drawCircle;
boolean drawGuidingDots;
// Dot variables
int DIMENSIONS = 800; // Dimensions of the window
int dotNum = 20; // Number of "dots" to be displayed on-screen. Must be less than DIMENSIONS
int dotSize = 10; // Size of the "dots" being displayed on-screen. Must be less than DIMENSIONS/dot_num
int dotDist = 20; // Distance between independent dots. Must be less than (DIMENSIONS/dot_num)-dot_size, but larger than dot_size (otherwise the dots overlap)
int unitDisplacement = 0; // The displacement between the top-left corner of each "dot"
int startCoordinates = 0; // The x and y coordinates
// Circle variables
boolean decidingCircle = false; // We are currently creating a circle. Not yet finished
boolean decidedCircle = false; // We currently have a circle
int circleX = 0; // X-coordinates of circle center
int circleY = 0; // Y-coordinates of circle center
int circleWidth = 0; // Circle radius
// Highlight variables
boolean highlightedDots[][] = new boolean[dotNum][dotNum]; // Array signifying each dot's designation as either grey or blue
int innerRadius = 0; // Radius for the innermost circle
int outerRadius = 0; // Radius for the outermost circle
// Circle-from-dot variables
boolean generated = false;
PVector dot1; // Farthest pair of dots
PVector dot2;
PVector circleCenter; // Center of the circle generated by the chosen dots
float selectedCircleWidth;
ArrayList<PVector> selectedDots;
float minimumGain = 0.01f;
// Button variables
PVector gen = new PVector(599, 749);
PVector genDimensions = new PVector(200, 50);
boolean displayWarning = false;

// The initiation method. Sets up the initial state of the program
public void setup(){
   // Initialize the size of the window (need to change them manually here, variables not accepted by method)
  background(255); // Color the background with white
  // Initialize calculated variables
  unitDisplacement = dotSize + dotDist;
  startCoordinates = (DIMENSIONS/2) - (10*unitDisplacement); // The coordinates of the top-left "dot"
  drawDots(); // Draw the dots
  drawCircle = true;
  drawGuidingDots = false;
  selectedDots = new ArrayList<PVector>();
}

public void draw(){ // Method called every frame
  background(255);
  // Type instructions
  fill(0);
  textSize(32);
  text("Press 'D' to switch modes", 20, 40);
  String currMode = "";
  if(drawCircle)
    currMode = "Circle Drawing Mode";
  else
    currMode = "Dot selection mode";
  // Warning text
  if(displayWarning)
    text("Please Select at least 2 dots", 20, DIMENSIONS - 40);
  text("Current mode: " +currMode, 20, 80);
  drawDots();
  if(drawCircle){ // We'll draw a circle by dragging the mouse
    stroke(0);
    noFill();
    if(decidingCircle){ // While we're deciding, the circle radius gets resized
      constructDots();
      circleWidth = (int)(dist(mouseX, mouseY, circleX, circleY)*2.0f);
      circle(circleX, circleY, circleWidth); // Draw the circle as we're resizing it
    }
    if(decidedCircle){
      stroke(0, 0, 255);
      circle(circleX, circleY, circleWidth); // Draw the circle decided on
      stroke(0);
      circle(circleX, circleY, innerRadius*2); // Draw the inner circle
      circle(circleX, circleY, outerRadius*2); // Draw the outer circle
    }
  }
  else if(drawGuidingDots){
    // Draw the "generate" button
    fill(100);
    stroke(0);
    rect(gen.x, gen.y, genDimensions.x, genDimensions.y);
    // Write over it
    fill(0);
    textSize(32);
    text("Generate", gen.x+20, gen.y+40);
    noFill();
    if(generated){
      // Draw the new circle
      circle(circleCenter.x, circleCenter.y, selectedCircleWidth);
    }
  }
}

public void mousePressed() {
  if(drawCircle){
    decidingCircle = true;
    decidedCircle = false;
    circleX = mouseX;
    circleY = mouseY;
  }
  else if(drawGuidingDots){
    if(mouseX >= gen.x && mouseY >= gen.y){
      if(selectedDots.size() < 2)
        displayWarning = true;
      else{
        displayWarning = false;
        generate();
        generated = true;
      }
    }
    else{
      int x = convertToDot(mouseX);
      int y = convertToDot(mouseY);
      PVector tmp = new PVector(convertToCor(x), convertToCor(y));
      highlightedDots[y][x] = !highlightedDots[y][x];
      // Add or remove the dot from the arraylist
      if(highlightedDots[y][x])
        selectedDots.add(tmp);
      else
        selectedDots.remove(tmp);
    }
  }
}

public void mouseReleased() {
  if(drawCircle){
    decidingCircle = false;
    decidedCircle = true;
    highlightDots();
    setMarginCircles();
  }
}

public void keyPressed(){
  switch(key){
    case 'd':
      drawGuidingDots = !drawGuidingDots;
      drawCircle = !drawCircle;
      constructDots(); // Reset all the dots
      selectedDots.clear(); // All dots
      generated = false;
      break;
    default:
      break;
  }
}

public void constructDots(){ // Resets the dot colors to grey
  for (int i=0; i<dotNum; i++){
    for (int j = 0; j<dotNum; j++){
      highlightedDots[i][j] = false;
    }
  }
}

public void drawDots(){
  int x = startCoordinates, y = startCoordinates;
  noStroke(); // Removing "stroke" from the squares, so they have no outline, and are seen as they are
  for (int i=0; i<dotNum; i++){ // Run through the y coordinates top to bottom
    for (int j = 0; j<dotNum; j++){ // Run through the x coordinates left to right
      if(highlightedDots[i][j]) // If this "dot" highlighted, color it blue
        fill(0, 0, 255);
      else
        fill(127); // Else, color it grey
      square(convertToCor(j), convertToCor(i), dotSize); // Draw square
      x += unitDisplacement; // Iterate the x
    }
    x = startCoordinates; // Zero the x
    y += unitDisplacement; // Iterate the y
  }
}

public void highlightDots(){
  ////// The general methodology is as follows: for each square set of 4 dots, we pick the closest two to the circle to highlight
  //// First, we establish the boundary within which we'll search the dots
  int radius = circleWidth / 2;
  // Get the left boundary coordinates
  int startX = circleX - radius;
  int startY = circleY - radius;
  // Get the starting row and columns for the dots we'll be evaluating
  int startRow = convertToDot(startX);
  int startCol = convertToDot(startY);
  // Get the ending row and columns
  int endRow = (int)Math.ceil(circleWidth/1.0f/unitDisplacement) + startRow;
  int endCol = (int)Math.ceil(circleWidth/1.0f/unitDisplacement) + startCol;
  if(endRow >=20)
    endRow = 19;
  if(endCol >=20)
    endCol = 19;
  //// Now we have the boundaries. Let's iterate through them
  for (int i = startRow; i<endRow; i++){ // Run through the boundary
    for (int j = startCol; j<endCol; j++){
      // Create an array for the dots and the relevant distances
      int [][]distances = new int[2][4];
      // First, get the distance between the circle center and the dots
      int upperLeft = (int)dist(convertToCor(i), convertToCor(j), circleX, circleY);
      int upperRight = (int)dist(convertToCor(i+1), convertToCor(j), circleX, circleY);
      int lowerLeft = (int)dist(convertToCor(i), convertToCor(j+1), circleX, circleY);
      int lowerRight = (int)dist(convertToCor(i+1), convertToCor(j+1), circleX, circleY);
      distances[0][0] = upperLeft;
      distances[1][0] = 1;
      distances[0][1] = upperRight;
      distances[1][1] = 2;
      distances[0][2] = lowerLeft;
      distances[1][2] = 3;
      distances[0][3] = lowerRight;
      distances[1][3] = 4;
      // Find the closest and farthest dot
      int closestDot = upperLeft;
      int farthestDot = upperLeft;
      for(int z = 1; z < 4; z++){
        closestDot = Math.min(closestDot, distances[0][z]);
        farthestDot = Math.max(farthestDot, distances[0][z]);
      }
      // Check if the closest dot falls within the circle while the farthest falls outside
      if(closestDot <= radius && farthestDot > radius){
        // If so, that means the circle runs "through" the 4-dot square, and at least two dots of the square will count as part of the circle
        // Get the closest two dots to the circle's edge
        int closestDot1 = 1;
        int closestDist1 = abs(upperLeft - radius);
        int closestDot2 = 1;
        int closestDist2 = abs(upperLeft - radius);
        for(int z = 1; z < 4; z++){
          if(abs(distances[0][z] - radius) <= closestDist1){
            closestDot1 = distances[1][z];
            closestDist1 = abs(distances[0][z] - radius);
          }
          else if(abs(distances[0][z] - radius) <= closestDist2){
            closestDot2 = distances[1][z];
            closestDist2 = abs(distances[0][z] - radius);
          }
        }
        // Now we convert closestDot1 and closestDot2 into their dot serials
        int row1 = i;
        int row2 = i;
        int col1 = j;
        int col2 = j;
        switch(closestDot1){
          case 2:
            if(row1 < 19)
              row1++;
            break;
          case 3:
            if(col1 < 19)
              col1++;
            break;
          case 4:
            if(row1 < 19)
              row1++;
            if(col1 < 19)
              col1++;
            break;
        }
        switch(closestDot2){
          case 2:
            if(row2 < 19)
              row2++;
            break;
          case 3:
            if(col2 < 19)
              col2++;
            break;
          case 4:
            if(row2 < 19)
              row2++;
            if(col2 < 19)
              col2++;
            break;
        }
        println("r1: " + row1);
        println("r2: " + row2);
        println("c1: " + col1);
        println("c2: " + col2);
        highlightedDots[col1][row1] = true;
        highlightedDots[col2][row2] = true;
      }
    }
  }
  // For debugging. This section draws a red square at the upper left most and lower right most boundary of the circle
  //int endX = startCoordinates + (endRow * unitDisplacement);
  //int endY = startCoordinates + (endCol * unitDisplacement);
  //startX = startCoordinates + (startRow * unitDisplacement);
  //startY = startCoordinates + (startCol * unitDisplacement);
  //// We now have the left and uppermost bounds
  //fill(255, 0, 0);
  //square(startX, startY, 10);
  //square(endX, endY, 10);
}

public int convertToDot(int d){ // Converts x or y coordinates into the closest row or column number respectively
  // Check if the dot we're picking is out of bounds
  if(d >= startCoordinates + dotNum*unitDisplacement)
    return 19;
  else if(d < startCoordinates)
    return 0;
  return (d - startCoordinates)/unitDisplacement;
}

public int convertToCor(int i){ // Converts row or column into x or y coordinates respectively
  return startCoordinates + (i * unitDisplacement);
}

public void setMarginCircles(){ // Set the margin
  int closest = circleWidth/2;
  int farthest = circleWidth/2;
  for (int i=0; i<dotNum; i++){
    for (int j = 0; j<dotNum; j++){
      if(highlightedDots[i][j]){
        float d = dist(convertToCor(j), convertToCor(i), circleX, circleY);
        closest = (int)Math.min(closest, d);
        farthest = (int)Math.max(farthest, d);
      }
    }
  }
  println("Closest: "+closest*2);
  println("Farthest: "+farthest*2);
  println("Radius: "+circleWidth);
  innerRadius = closest;
  outerRadius = farthest;
}

public void generate(){
  ////// We're going to find the farthest two points, then draw a circle with them at the center. After, we'll adjust the circle's position and size to minimize least-square-distance
  //// Start with finding farthest two points
  setFarthestPoints();
  //// Now generate an initial circle out of them
  //circleCenter = PVector.add(dot1, dot2).div(2); // The center of the circle will be the midpoint between the farthest dots
  selectedCircleWidth = PVector.dist(dot1, dot2); // The width will be the distance between them
  //// Now we optimize the circle's position and radius
  for(int i = 0; i < 100; i++){
    float c1 = optimizeCirclePos();
    float c2 = optimizeCircleRad();
    //if(c1 + c2 < minimumGain)
    //  break;
  }
  println("Circle: " + circleCenter.x + ", " + circleCenter.y);
  println("Circle Width: " + selectedCircleWidth);
  // We've generated the best circle we can get
}

public float optimizeCirclePos(){
  //// We want to minimize the distances from circle to selected points as much as possible, to fit better
  // This keeps track of the latest change we made
  float change = 0;
  // First, we create an arraylist of directional vectors
  ArrayList<PVector> goTo = new ArrayList<PVector>();
  goTo.add(new PVector(-1, -1));
  goTo.add(new PVector(0, -1));
  goTo.add(new PVector(+1, -1));
  goTo.add(new PVector(-1, 0));
  goTo.add(new PVector(0, 0));
  goTo.add(new PVector(+1, 0));
  goTo.add(new PVector(-1, +1));
  goTo.add(new PVector(0, +1));
  goTo.add(new PVector(+1, +1));
  // They will act as "directions" for our circle center to inch towards
  // We will loop over a multitude of iterations until the improvement is negligible, or we reach 100 moves
  for(int i = 0; i < 1000; i++){
    // Now we loop over each direction being added to the circle center, and pick the best one
    PVector bestMove = new PVector();
    double leastDist = Double.POSITIVE_INFINITY;
    float t = 0;
    for(PVector tmp: goTo){
      t = distancesFromCircle(selectedDots, PVector.add(circleCenter, tmp), selectedCircleWidth);
      if(t < leastDist){
        leastDist = t;
        bestMove = tmp;
      }
    }
    // We found the best direction for one iteration!
    // Compare it to our current setting, and calculate the change
    change = distancesFromCircle(selectedDots, circleCenter, selectedCircleWidth) - t;
    circleCenter.add(bestMove);
    //if(change < minimumGain){
    //  break;
    //}
    //else{
    //  circleCenter.add(bestMove);
    //}
  }
  return change;
}

public float optimizeCircleRad(){
  // Now we do the same, but for radius
  // This keeps track of the latest change we made
  float change = 0;
  ArrayList<Integer> resize = new ArrayList<Integer>();
  resize.add(-1);
  resize.add(0);
  resize.add(1);
  // We will loop over a multitude of iterations until the improvement is negligible, or we reach 100 moves
  for(int i = 0; i < 1000; i++){
    // Now we loop over each direction being added to the circle center, and pick the best one
    int bestResize = 0;
    double leastDist = Double.POSITIVE_INFINITY;
    float t = 0;
    for(int tmp: resize){
      t = distancesFromCircle(selectedDots, circleCenter, selectedCircleWidth + tmp);
      if(t < leastDist){
        leastDist = t;
        bestResize = tmp;
      }
    }
    // We found the best direction for one iteration!
    // Compare it to our current setting, and calculate the change
    change = distancesFromCircle(selectedDots, circleCenter, selectedCircleWidth) - t;
    selectedCircleWidth += bestResize;
    //if(change < minimumGain){
    //  break;
    //}
    //else{
    //  selectedCircleWidth += bestResize;
    //}
  }
  return change;
}

public float distancesFromCircle(ArrayList<PVector> points, PVector circle, float cWidth){
  float rad = cWidth/2;
  float total = 0;
  for(PVector tmp: points){
    total += distanceFromCircle(circle.x, circle.y, tmp.x, tmp.y, rad);
  }
  return total;
}

public void setFarthestPoints(){
 // Find the mean of all the points
 PVector mean = new PVector();
 for (PVector tmp : selectedDots) {
   mean.add(tmp);
 }
 mean.div(selectedDots.size());
 // Measure the difference between all points and the mean, take the point the largest distance from the mean
 float largestDist = 0;
 for (PVector tmp : selectedDots) {
   float tmpDist = mean.dist(tmp);
   if(tmpDist > largestDist){
     largestDist = tmpDist;
     dot1 = tmp;
   }
 }
 //  Find the point farthest from it
 largestDist = 0;
 for (PVector tmp : selectedDots) {
   float tmpDist = mean.dist(dot1);
   if(tmpDist > largestDist){
     largestDist = tmpDist;
     dot2 = tmp;
   }
 }
 // We have found the farthest two points
 // Convert them to their coordinates
 dot1 = new PVector(dot1.x, dot1.y);
 dot2 = new PVector(dot2.x, dot2.y);
 circleCenter = new PVector(mean.x, mean.y);
}

public float distanceFromCircle(float circX, float circY, float px, float py, float rad){ // Returns the distance between a point and the circle's edge
  float d = (int)dist(circX, circY, px, py);
  return abs(d - rad);
}
  public void settings() {  size(800, 800); }
  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Grid" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
